--https://m.baidu.com/?from=1019023c#iact=wiseindex%2Ftabs%2Fnews%2Factivity%2Fnewsdetail%3D%257B%2522linkData%2522%253A%257B%2522name%2522%253A%2522iframe%252Fmib-iframe%2522%252C%2522id%2522%253A%2522feed%2522%252C%2522index%2522%253A0%252C%2522url%2522%253A%2522https%253A%252F%252Ffeed.baidu.com%252Ffeed%252Fdata%252Fwise%252Flandingpage%253Fs_type%253Dnews%2526dsp%253Dwise%2526nid%253D9435606372514195813%2526n_type%253D1%2526p_from%253D-1%2522%252C%2522title%2522%253Anull%257D%257D
一 总体来说设计模式分为三大类：
创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。
结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。
行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、
访问者模式、中介者模式、解释器模式。
总计23种
二、设计模式的六大原则
1、开闭原则（Open Close Principle）
开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。
所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，
后面的具体设计中我们会提到这点。
2、里氏代换原则（Liskov Substitution Principle）
里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 
里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，
软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。
实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。
—— From Baidu 百科
3、依赖倒转原则（Dependence Inversion Principle）
这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。
4、接口隔离原则（Interface Segregation Principle）
这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，
其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。
5、迪米特法则（最少知道原则）（Demeter Principle）
为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。
6、合成复用原则（Composite Reuse Principle）
原则是尽量使用合成/聚合的方式，而不是使用继承。


1.策略模式(Strategy): 定义了算法家族, 分别封装起来, 让它们之间可以互相替换. 
比如Collections.sort(List list, Comparator c); 可以通过实现多个Comparator接口来达到多种排序的目的. 
2.装饰着模式(Decorator): 动态的给一个对象添加一些额外的职责. 
比如java.io包. BufferedInputStream封装了FileInputStream, 它们都实现了InputStream接口, 但前者实现了readLine方法. 
3.代理模式(Proxy): 为其他对象提供一种代理以控制对这个对象的访问. 
比如在用户登录时, 真正的登录类和代理登录类都实现了Login接口, 不同的是Proxy类的方法中增加了用户是否合法的判断, 只有合法时才去调用真正登录类的login方法. 用户访问的其实是Proxy的login方法. 
4.工厂模式(Factory): 定义一个用以创建对象的接口, 让子类决定实例化哪个类. 
当遇到需要根据某个前提条件创建不同的类实现时, 会实用工厂模式. 
5.模板模式(Template): 定义一个操作中的算法骨架, 而将一些步骤延迟到子类中. 
比如HibernateTemplate, 在Template中已经定义了Connection开关的实现, 用户只需要在子类中根据不同的业务写不同的sql. 
6.外观模式(Facade): 为子系统中的一组接口提供一个一致的界面. 
一直在用, 比如DBUtil, 将所有数据库对象封装了, 只留了DBUtil.getDBUtil()这个接口. 
7.建造者模式(Builder): 将一个复杂对象的构建与它的表示分离. 
8.观察者模式(Observer): 定义了一种一对多的依赖关系,让多个观察者对象同时监听某一主题对象,在它的状态发生变化时,会通知所有的观察者. 
比如ServletContextListener, 在applcation启动时, 会通知所有这个接口的实现类. 
9.抽象工厂模式(Abstract Factory): 提供一个创建一系列相关或相互依赖对象的接口, 而无需指定它们具体的类. 
10.适配器模式(Adapter): 将一个类的接口转换成客户希望的另一个接口. 
11.单例模式(Singleton): 保证一个类仅有一个实例,并提供一个访问它的全局控制点. 
比如在加载配置文件时, 可使用该模式. 
12.命令模式(Command): 将一个请求封装成为一个对象, 使可以用不同的请求对客户进行参数化. 
比如Struts的MVC结构, 其实就是个Command模式. 